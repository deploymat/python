import os
import time
import socket
import subprocess
from pathlib import Path
from typing import Dict, List, Optional
import paramiko
from .utils import Logger


class Deployment:
    """Klasa zarzƒÖdzajƒÖca deploymentem na VPS"""

    def __init__(self, config: Dict, logger: Logger):
        """
        Inicjalizuje deployment

        Args:
            config: Konfiguracja projektu
            logger: Logger do wy≈õwietlania komunikat√≥w
        """
        self.config = config
        self.logger = logger
        self.ssh_client = None
        self.project_name = "pydock-app"

    def test_connection(self):
        """Testuje po≈ÇƒÖczenie SSH z VPS"""
        self.logger.info("üîå Testowanie po≈ÇƒÖczenia z VPS...")

        try:
            self.ssh_client = paramiko.SSHClient()
            self.ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

            # Pr√≥buj r√≥≈ºne metody uwierzytelniania
            vps_ip = self.config['vps_ip']
            ssh_key_path = self.config.get('ssh_key_path')

            if ssh_key_path and os.path.exists(ssh_key_path):
                # Uwierzytelnianie kluczem SSH
                self.ssh_client.connect(
                    hostname=vps_ip,
                    username='root',
                    key_filename=ssh_key_path,
                    timeout=10
                )
            else:
                # Uwierzytelnianie has≈Çem (poprosi o has≈Ço)
                password = input(f"Podaj has≈Ço dla root@{vps_ip}: ")
                self.ssh_client.connect(
                    hostname=vps_ip,
                    username='root',
                    password=password,
                    timeout=10
                )

            self.logger.success("‚úÖ Po≈ÇƒÖczenie z VPS nawiƒÖzane")

        except Exception as e:
            self.logger.error(f"‚ùå Nie mo≈ºna po≈ÇƒÖczyƒá siƒô z VPS: {str(e)}")
            raise

    def check_dns(self):
        """Sprawdza konfiguracjƒô DNS"""
        self.logger.info("üåê Sprawdzanie konfiguracji DNS...")

        domain = self.config['domain']
        vps_ip = self.config['vps_ip']

        subdomains = ['app', 'site', 'api', 'www']
        dns_ok = True

        for subdomain in subdomains:
            full_domain = f"{subdomain}.{domain}"

            try:
                resolved_ip = socket.gethostbyname(full_domain)
                if resolved_ip == vps_ip:
                    self.logger.success(f"‚úÖ {full_domain} ‚Üí {resolved_ip}")
                else:
                    self.logger.warning(f"‚ö†Ô∏è  {full_domain} ‚Üí {resolved_ip} (oczekiwano {vps_ip})")
                    dns_ok = False
            except socket.gaierror:
                self.logger.warning(f"‚ö†Ô∏è  {full_domain} ‚Üí nie rozwiƒÖzano")
                dns_ok = False

        # Sprawd≈∫ g≈Ç√≥wnƒÖ domenƒô
        try:
            resolved_ip = socket.gethostbyname(domain)
            if resolved_ip == vps_ip:
                self.logger.success(f"‚úÖ {domain} ‚Üí {resolved_ip}")
            else:
                self.logger.warning(f"‚ö†Ô∏è  {domain} ‚Üí {resolved_ip} (oczekiwano {vps_ip})")
                dns_ok = False
        except socket.gaierror:
            self.logger.warning(f"‚ö†Ô∏è  {domain} ‚Üí nie rozwiƒÖzano")
            dns_ok = False

        if not dns_ok:
            self.logger.warning("‚ö†Ô∏è  Niekt√≥re domeny nie wskazujƒÖ na VPS. Deployment mo≈ºe nie dzia≈Çaƒá poprawnie.")
            response = input("Czy chcesz kontynuowaƒá? (y/N): ")
            if response.lower() != 'y':
                raise Exception("Deployment anulowany przez u≈ºytkownika")

    def prepare_vps(self):
        """Przygotowuje VPS do deploymentu"""
        self.logger.info("üîß Przygotowywanie VPS...")

        # Instaluj Docker je≈õli nie ma
        self._run_command("which docker || curl -fsSL https://get.docker.com | sh")
        self._run_command(
            "which docker-compose || curl -L \"https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose && chmod +x /usr/local/bin/docker-compose")

        # Utw√≥rz katalog projektu
        self._run_command(f"mkdir -p /opt/{self.project_name}")

        # Prze≈õlij pliki
        self._upload_files()

        # Wygeneruj .env z has≈Çami
        self._generate_env_file()

        self.logger.success("‚úÖ VPS przygotowany")

    def deploy_containers(self):
        """Uruchamia kontenery Docker na VPS"""
        self.logger.info("üöÄ Uruchamianie kontener√≥w...")

        project_dir = f"/opt/{self.project_name}"

        # Zatrzymaj stare kontenery
        self._run_command(f"cd {project_dir} && docker-compose -f docker-compose.prod.yml down || true")

        # Uruchom nowe
        self._run_command(f"cd {project_dir} && docker-compose -f docker-compose.prod.yml up -d --build")

        # Poczekaj na uruchomienie
        time.sleep(10)

        self.logger.success("‚úÖ Kontenery uruchomione")

    def verify_deployment(self):
        """Weryfikuje czy deployment siƒô powi√≥d≈Ç"""
        self.logger.info("üîç Weryfikacja deploymentu...")

        project_dir = f"/opt/{self.project_name}"

        # Sprawd≈∫ status kontener√≥w
        stdout, stderr = self._run_command(f"cd {project_dir} && docker-compose -f docker-compose.prod.yml ps")

        self.logger.info("üìä Status kontener√≥w:")
        print(stdout)

        # Sprawd≈∫ logi Caddy
        stdout, stderr = self._run_command(
            f"cd {project_dir} && docker-compose -f docker-compose.prod.yml logs caddy | tail -5")

        if "certificate obtained successfully" in stdout.lower() or "serving" in stdout.lower():
            self.logger.success("‚úÖ SSL certyfikaty wygenerowane")
        else:
            self.logger.warning("‚ö†Ô∏è  SSL certyfikaty mogƒÖ byƒá jeszcze generowane...")

        # Poka≈º dostƒôpne adresy
        domain = self.config['domain']
        self.logger.info("üåê Twoja aplikacja jest dostƒôpna pod adresami:")
        self.logger.info(f"   G≈Ç√≥wna strona:    https://{domain}")
        self.logger.info(f"   Aplikacja:        https://app.{domain}")
        self.logger.info(f"   Strona statyczna: https://site.{domain}")
        self.logger.info(f"   API:              https://api.{domain}")

    def show_status(self):
        """Pokazuje aktualny status aplikacji"""
        project_dir = f"/opt/{self.project_name}"

        self.logger.info("üìä Status aplikacji:")
        stdout, stderr = self._run_command(f"cd {project_dir} && docker-compose -f docker-compose.prod.yml ps")
        print(stdout)

    def show_logs(self, service: str = None, follow: bool = False):
        """
        Pokazuje logi aplikacji

        Args:
            service: Nazwa us≈Çugi
            follow: Czy ≈õledziƒá logi na ≈ºywo
        """
        project_dir = f"/opt/{self.project_name}"

        if service:
            cmd = f"cd {project_dir} && docker-compose -f docker-compose.prod.yml logs {service}"
        else:
            cmd = f"cd {project_dir} && docker-compose -f docker-compose.prod.yml logs"

        if follow:
            cmd += " -f"

        stdout, stderr = self._run_command(cmd)
        print(stdout)

    def stop_containers(self):
        """Zatrzymuje kontenery"""
        project_dir = f"/opt/{self.project_name}"
        self._run_command(f"cd {project_dir} && docker-compose -f docker-compose.prod.yml down")

    def _run_command(self, command: str) -> tuple:
        """
        Wykonuje komendƒô na VPS przez SSH

        Args:
            command: Komenda do wykonania

        Returns:
            Tuple (stdout, stderr)
        """
        if not self.ssh_client:
            raise Exception("Brak po≈ÇƒÖczenia SSH")

        stdin, stdout, stderr = self.ssh_client.exec_command(command)
        stdout_text = stdout.read().decode('utf-8')
        stderr_text = stderr.read().decode('utf-8')

        if stderr_text and "warning" not in stderr_text.lower():
            self.logger.debug(f"Command: {command}")
            self.logger.debug(f"STDERR: {stderr_text}")

        return stdout_text, stderr_text

    def _upload_files(self):
        """Przesy≈Ça pliki projektu na VPS"""
        self.logger.info("üìÅ Przesy≈Çanie plik√≥w...")

        sftp = self.ssh_client.open_sftp()
        project_dir = f"/opt/{self.project_name}"

        # Lista plik√≥w do przes≈Çania
        files_to_upload = [
            "docker-compose.prod.yml",
            "Caddyfile.prod",
        ]

        # Przesy≈Çaj pliki
        for file_path in files_to_upload:
            if os.path.exists(file_path):
                remote_path = f"{project_dir}/{file_path}"
                sftp.put(file_path, remote_path)
                self.logger.debug(f"Przes≈Çano: {file_path}")

        # Przesy≈Çaj katalogi
        directories_to_upload = ["web-app", "static-site"]

        for directory in directories_to_upload:
            if os.path.exists(directory):
                self._upload_directory(sftp, directory, f"{project_dir}/{directory}")

        sftp.close()
        self.logger.success("‚úÖ Pliki przes≈Çane")

    def _upload_directory(self, sftp, local_dir: str, remote_dir: str):
        """Przesy≈Ça katalog rekurencyjnie"""
        try:
            sftp.mkdir(remote_dir)
        except:
            pass  # Katalog ju≈º istnieje

        for item in os.listdir(local_dir):
            local_path = os.path.join(local_dir, item)
            remote_path = f"{remote_dir}/{item}"

            if os.path.isfile(local_path):
                sftp.put(local_path, remote_path)
            elif os.path.isdir(local_path):
                self._upload_directory(sftp, local_path, remote_path)

    def _generate_env_file(self):
        """Generuje plik .env z bezpiecznymi has≈Çami"""
        import secrets
        import string

        # Wygeneruj bezpieczne has≈Ço
        alphabet = string.ascii_letters + string.digits
        db_password = ''.join(secrets.choice(alphabet) for _ in range(32))

        env_content = f"""# Wygenerowane automatycznie przez PyDock
DOMAIN={self.config['domain']}
DB_PASSWORD={db_password}
FLASK_ENV=production
"""

        project_dir = f"/opt/{self.project_name}"

        # Utw√≥rz plik .env na VPS
        stdin, stdout, stderr = self.ssh_client.exec_command(f"cat > {project_dir}/.env << 'EOF'\n{env_content}\nEOF")

        self.logger.success("‚úÖ Plik .env wygenerowany")

    def __del__(self):
        """Zamyka po≈ÇƒÖczenie SSH"""
        if self.ssh_client:
            self.ssh_client.close()